REGRA PARA IDE DE IA — GERAÇÃO FLUTTER VIA MCP FIGMA
==================================================

OBJETIVO
--------
Gerar código Flutter a partir do Figma utilizando MCP.
Nenhuma decisão criativa, inferência ou adaptação é permitida.

REGRA GLOBAL (BLOQUEANTE)
------------------------
- O MCP é a ÚNICA fonte da verdade.
- Tudo o que não estiver explicitamente definido no MCP é PROIBIDO.
- Em caso de ausência, ambiguidade ou conflito de informação → FALHAR IMEDIATAMENTE.
- Não assumir, não inferir, não completar, não adaptar.
- Não interpretar Figma, tokens ou componentes.

==================================================
DATA-IA-DEVELOPMENT-ANNOTATIONS (BLOQUEANTE)
==================================================

CRÍTICO: O Cursor DEVE respeitar TODO e QUALQUER atributo data-ia-development-annotations
como regra obrigatória. Esses atributos vêm do get_design_context (ex.: em className,
HTML, ou código exportado do Figma).

Exemplo:
  data-ia-development-annotations="Respeite a font-size"
  → O font-size indicado no mesmo elemento DEVE ser aplicado exatamente.

Regras:
- Todo data-ia-development-annotations é vinculante. Não ignorar.
- Se indicar "Respeite a font-size" → usar o token tipográfico que corresponde ao
  size/line-height/weight do elemento.
- Mapear os valores CSS/var do Figma aos TypographyTokens do projeto via DEPARA abaixo.

==================================================
O QUE O FIGMA MCP RETORNA (ESTADO ATUAL)
==================================================

Calls disponíveis: get_design_context, get_screenshot, get_metadata.

Respostas observadas:

1. get_design_context:
   - Caso completo: estrutura, hierarquia, tokens, props, código — incluindo o nome
     do componente/página (ex: export default function SneakerSubscriptionPage()).
     Esse nome é CRÍTICO e deve ser usado exatamente no Flutter.
   - Pode retornar tamanhos de font via typography-tokens (ex: var(--typography-tokens/
     display-small/size,36px)) e atributos data-ia-development-annotations (ex:
     "Respeite a font-size"). Todos devem ser respeitados e mapeados ao DS.
   - Caso parcial: apenas aviso "IMPORTANT: After you call this tool, you MUST call get_screenshot".
   - Ausente: nome de tokens, TypeScript props, hierarquia de layout.

2. get_screenshot:
   - Retorna: imagem + descrição textual da UI (layout, seções, componentes visuais,
     cores hex aproximadas, tipografia aproximada, ícones, botões).
   - Inclui: "Primary Button", "Secondary Button", "List item", "Close button",
     "Title", "Subtitle", "Supporting text", cores (#673AB7, #FBF7FB, etc.).

3. get_metadata:
   - Caso completo: XML com estrutura de nodes, atributo name do symbol.
   - Caso parcial: apenas aviso "IMPORTANT: If you call this tool, you MUST call get_design_context".
   - Ausente: nome do componente para arquivo/classe Flutter.

==================================================
DEPARA FIGMA MCP ↔ DESIGN SYSTEM (quando MCP retorna parcial)
==================================================

Quando get_design_context ou get_metadata não retornam dados estruturados,
usar EXCLUSIVAMENTE este depara para mapear descrições do get_screenshot
aos componentes e tokens do projeto. Não inventar mapeamentos.

COMPONENTES VISUAIS (screenshot description → DS):
  - "Close button" / "X icon" / "dismiss"     → IconButtonStandard (icon: Icons.close)
  - "List item" com icon + title + supporting → ListItem (leadingIcon, title, supportingText, showDivider)
  - "Primary Button" / "solid purple button"  → ButtonFilled (label)
  - "Secondary Button" / "outline button"     → ButtonOutlined (label)
  - "Divider" / "separator" entre itens       → ListItem(showDivider: true) ou Divider
  - "Person outline icon" em list item        → Icons.person_outline

TIPOGRAFIA (screenshot description → TypographyTokens):
  - "large bold title" / "main title" / "H1"  → TypographyTokens.titleLarge
  - "subtitle" / "smaller regular"            → TypographyTokens.bodyMedium
  - "list item primary text"                  → TypographyTokens.bodyLarge (via ListItem)
  - "supporting text" / "lorem ipsum"         → TypographyTokens.bodyMedium (via ListItem)
  - Botões                                    → TypographyTokens.labelLarge (via ButtonFilled/ButtonOutlined)

TIPOGRAFIA (get_design_context retorna tamanhos — Figma tokens → TypographyTokens):
  Quando get_design_context retornar typography-tokens no className/HTML (ex.:
  typography-tokens/display-small/size, line-height, weight), fazer o depara exato:

  Figma typography-tokens/display-small (36px, 44px, SemiBold)
    → TypographyTokens.displaySmall

  Figma typography-tokens/headline-large (32px, 40px, SemiBold)
    → TypographyTokens.headlineLarge

  Figma typography-tokens/title-large (22px, 28px, Medium)
    → TypographyTokens.titleLarge

  Figma typography-tokens/title-medium (16px, 24px, Medium)
    → TypographyTokens.titleMedium

  Figma typography-tokens/title-small (14px, 20px, Medium)
    → TypographyTokens.titleSmall

  Figma typography-tokens/body-large (16px, 24px, Regular)
    → TypographyTokens.bodyLarge

  Figma typography-tokens/body-medium (14px, 20px, Regular)
    → TypographyTokens.bodyMedium

  Figma typography-tokens/body-small (12px, 16px, Regular)
    → TypographyTokens.bodySmall

  Figma typography-tokens/label-large (14px, 20px, Medium)
    → TypographyTokens.labelLarge

  Exemplo: data-ia-development-annotations="Respeite a font-size" com
  text-[length:var(--typography-tokens/display-small/size,36px)] e
  leading-[var(--typography-tokens/display-small/line-height,44px)]
  → Usar TypographyTokens.displaySmall (36/44, SemiBold).

CORES (screenshot hex → Theme colorScheme / ColorTokens):
  - #673AB7, #6A4CAF, purple escuro          → colorScheme.primary
  - #FBF7FB, #F9F0FB, #F8F4FA, lavender      → colorScheme.surfaceContainerLow
  - #1C1C1E, #212121, dark grey/black        → colorScheme.onSurface
  - #4A4A4A, lighter grey                    → colorScheme.onSurfaceVariant
  - #E0E0E0, light grey line                 → colorScheme.outlineVariant
  - white text on purple                     → colorScheme.onPrimary

ESPAÇAMENTO (screenshot "padding"/"spacing" → GapTokens):
  - "substantial" / "large" entre seções      → GapTokens.gapExtraLarge
  - "moderate" / "noticeable" entre elementos → GapTokens.gapLarge ou gapMedium
  - "small" / "consistent" entre ícone e texto→ GapTokens.gapMedium
  - entre título e subtítulo                 → GapTokens.gapSmall
  - entre botões                             → GapTokens.gapMedium

OUTROS TOKENS:
  - "pill-shaped" / "heavily rounded" buttons → RadiusTokens.cornerFull
  - Padding horizontal de conteúdo           → GapTokens.gapLarge (horizontal)

HIERARQUIA DE LAYOUT (quando não vem do get_design_context):
  - Top: imagem/frame + close overlay
  - Middle: título, subtítulo, lista de itens (cada um com divider exceto último)
  - Bottom: primary button, secondary button
  - Ordem: top-down conforme descrição do screenshot.

REFERÊNCIA — COMPONENTES E TOKENS DO PROJETO:
  Componentes: Avatar, ButtonFilled, ButtonOutlined, Divider, IconButtonStandard,
    IconButtonFilled, IconButtonOutlined, ListItem, TitleList, TopBar.
  Tokens: GapTokens, PaddingTokens, RadiusTokens, SizeTokens, TypographyTokens,
    ColorTokens (via Theme.colorScheme: primary, onPrimary, surface, surfaceContainerLow,
    surfaceVariant, onSurface, onSurfaceVariant, outline, outlineVariant).

==================================================
FLUXO OBRIGATÓRIO MCP (BLOQUEANTE)
==================================================

Ao implementar qualquer design do Figma, é OBRIGATÓRIO:

1. Chamar get_design_context (nodeId do Figma)
2. Chamar get_screenshot (mesmo nodeId)

- Não gerar código sem ter usado ambos os responses.
- Estrutura, hierarquia, espaçamentos e direção do layout vêm EXCLUSIVAMENTE desses dois calls.
- Nunca inferir informações visuais ausentes.

==================================================
NOMES E IDENTIDADE DE COMPONENTES (BLOQUEANTE)
==================================================

CRÍTICO: O nome da página ou componente Flutter DEVE ser idêntico ao retornado
pelo MCP. Essa identidade é MUITO IMPORTANTE e deve ser rigorosamente respeitada.

REGRA OBRIGATÓRIA ANTES DE CRIAR QUALQUER COMPONENTE/PÁGINA:
- SEMPRE verificar o nome do componente/página no retorno do get_design_context do MCP Figma.
- O nome pode aparecer em código TypeScript/React exportado (ex.: export default function ComponentName()).
- NUNCA assumir ou inferir o nome baseado apenas na descrição visual ou no título da tela.
- Se o get_design_context não retornar o nome explicitamente, usar get_metadata para verificar o atributo `name` do symbol.
- Só usar fallback (derivar do contexto) quando AMBOS get_design_context E get_metadata não retornarem o nome.

Ordem de prioridade para o nome:

1. get_design_context (PRIORIDADE MÁXIMA):
   Quando o get_design_context retornar o nome do componente/página (ex.: em código
   TypeScript/React), esse nome é OBRIGATÓRIO para o Flutter.
   Exemplo retornado: export default function SneakerSubscriptionPage()
   → Nome Flutter OBRIGATÓRIO: SneakerSubscriptionPage
   → Arquivo: sneaker_subscription_page.dart
   → Classe: SneakerSubscriptionPage
   → Widgetbook: SneakerSubscriptionPage
   NUNCA renomear, adaptar ou traduzir. Usar EXATAMENTE como retornado.

2. get_metadata:
   Atributo `name` do symbol quando get_design_context não fornecer o nome.
   Exemplo: symbol id="43:151" name="Page Header Profile"
   → PageHeaderProfile (remover espaços, PascalCase)

3. Fallback (apenas quando 1 e 2 ausentes):
   Derivar do contexto (título principal da tela, node-id) em PascalCase.

Regras de conversão (para get_metadata ou fallback):
- Remover espaços
- PascalCase
- Nomes, props, tokens e estados são case-sensitive.

Esse nome determina obrigatoriamente:
- Nome do arquivo: snake_case do nome (ex: sneaker_subscription_page.dart)
- Nome da classe Flutter: idêntico ao nome
- Nome da página no Widgetbook: idêntico ao nome

Regras adicionais:
- Prefixos só podem existir se definidos explicitamente no MCP.
- Qualquer divergência é erro bloqueante.
- Nenhum renomeio alternativo é permitido.

==================================================
COMPONENTES DO DESIGN SYSTEM (PRIORIDADE MÁXIMA)
==================================================

- Componentes existentes no Design System DEVEM ser reutilizados obrigatoriamente.
- É PROIBIDO substituir componentes do DS por:
  - Widgets nativos do Flutter
  - Bibliotecas externas
  - Implementações manuais equivalentes

Regras:
- Widgets nativos do Flutter só podem ser usados como base interna de um componente do DS.
- Sempre importar o componente do DS.
- Em caso de conflito de nome, usar `hide` no import do Flutter e importar explicitamente o do DS.

Geração de componentes ou páginas:
- Usar APENAS componentes que já existem no Design System (mesmo projeto).
- Respeitar a API de cada componente: usar exatamente as propriedades (parâmetros) definidas no componente.
- Não inventar, adicionar ou omitir propriedades; não trocar nomes ou tipos de props.
- Se o Figma mapear para um componente do DS, usar esse componente com as props que ele declara — nada de reimplementar ou “adaptar” a API.

==================================================
PROPS E API PÚBLICA
==================================================

- O get_design_context fornece types (TypeScript) das props.
- Usar EXCLUSIVAMENTE o type cujo nome seja <ComponentName>Props.
- Ignorar qualquer outro type.

Regras:
- O widget Flutter deve expor EXATAMENTE as props definidas nesse type.
- Não adicionar, remover ou adaptar props.
- Não adicionar callbacks, textos, flags ou parâmetros não definidos no MCP.
- Valores default definidos no MCP devem ser respeitados.
- Cada prop deve virar um knob no Widgetbook.
- Não criar knobs extras.

==================================================
ESTADOS E VARIAÇÕES
==================================================

- Estados representam APENAS variações visuais.
- Estados NÃO representam lógica de interação.
- Não adicionar handlers, callbacks ou lógica não definida.
- Estruturas condicionais só são permitidas se explicitamente descritas no MCP.
- Não unificar, simplificar ou inferir estados.

==================================================
TELAS (MAPEAMENTO FIGMA ↔ FLUTTER)
==================================================

- Mapeamento é 1:1 entre componentes do Figma e widgets Flutter.
- Usar exatamente os componentes definidos no MCP.
- Não simular componentes com layout manual.
- Não duplicar implementações de componentes dentro de telas.

==================================================
TOKENS (BLOQUEANTE)
==================================================

- Usar EXCLUSIVAMENTE os tokens fornecidos pelo MCP OU, quando MCP retornar parcial,
  os tokens mapeados no DEPARA (seção acima).
- Tokens já vêm no formato Flutter e devem ser usados literalmente.
- Se MCP não fornecer tokens E o depara não mapear → FALHAR.

Proibições:
- Criar novos tokens
- Substituir tokens por valores fora do DS
- Modificar tokens existentes
- Usar valores fixos (ex: 16.0) em vez de tokens
- Usar fallback numérico não mapeado
- Usar withOpacity, lerp ou conversões numéricas (exceto dentro de componentes do DS)

==================================================
MAPEAMENTO DE TOKENS (BLOQUEANTE)
==================================================

- O nome do token define exatamente qual token usar.
- Não substituir tokens por equivalentes semânticos.
- Exemplo:
  MCP: GapTokens/gapMedium
  Flutter: GapTokens.gapMedium

==================================================
TIPOGRAFIA (BLOQUEANTE)
==================================================

- Tipografia deve vir exclusivamente de tokens MCP OU, quando MCP retornar parcial,
  dos TypographyTokens mapeados no DEPARA.
- Tokens: TypographyTokens.displaySmall, headlineLarge, titleLarge, titleMedium, bodyLarge, bodyMedium, labelLarge, etc.

REGRA CRÍTICA - TOKENS TIPOGRÁFICOS DO MCP:
- Quando get_design_context retornar informações explícitas de tipografia (ex.: typography-tokens/display-small,
  typography-tokens/title-large, etc.), essas informações são OBRIGATÓRIAS e devem ser respeitadas EXATAMENTE.
- NUNCA substituir ou ignorar tokens tipográficos retornados pelo MCP.
- Se o MCP indicar display-small para um título, usar TypographyTokens.displaySmall (NÃO titleLarge ou outro token).
- Mapear tokens do Figma para TypographyTokens conforme DEPARA (seção acima).
- Se o token tipográfico necessário não existir no DS nem no depara → FALHAR.

Proibições:
- Criar TextStyle manualmente (fontSize, fontWeight, fontFamily, etc.)
- Definir manualmente fontSize, fontWeight, fontFamily, height ou letterSpacing
- Usar Theme.of(context).textTheme em vez de TypographyTokens
- Substituir tokens tipográficos retornados pelo MCP por outros tokens "equivalentes"
- Ignorar informações de tipografia explícitas do get_design_context

==================================================
LAYOUT E HIERARQUIA (BLOQUEANTE)
==================================================

- A hierarquia do layout vem exclusivamente do MCP.
- Respeitar exatamente:
  - Ordem visual
  - Direção dos eixos
  - Aninhamento
  - Constraints

Regras:
- Ordem dos widgets deve seguir o Figma (top-down / left-right).
- Cada frame do Figma corresponde a um widget pai direto.
- Padding e margens definidos no Figma DEVEM ser implementados.
- Usar apenas tokens MCP para espaçamento.

Proibições:
- Criar layout responsivo
- Adaptar para diferentes telas
- Reordenar ou agrupar widgets

Quando MCP retornar parcial (apenas screenshot):
- Stack/Positioned são permitidos quando a descrição indicar overlay (ex: "close button overlaid on image").
- Expanded, Flexible, SizedBox são permitidos conforme hierarquia do DEPARA.
- Sem indicação no MCP nem no depara → evitar; se indispensável, documentar a exceção.

==================================================
EFEITOS VISUAIS
==================================================

- Bordas, sombras, blur e efeitos só podem existir se definidos no MCP.
- Não ajustar valores.
- Não simplificar efeitos.

==================================================
CONTEÚDO A IGNORAR
==================================================

- Instruções específicas de stacks que não sejam Flutter
- Documentações narrativas
- Textos explicativos
- Node IDs e metadados não fazem parte do código final

==================================================
WIDGETBOOK (BLOQUEANTE)
==================================================

REGRA OBRIGATÓRIA:
Ao criar ou atualizar QUALQUER componente ou página, é OBRIGATÓRIO realizar as seguintes tarefas:

TAREFA 1: Criar/Atualizar o componente ou página
- Criar o arquivo do componente/página em lib/components/ ou lib/templates/
- Exportar no barrel file correspondente (components.dart ou templates.dart)

TAREFA 2: Criar/Atualizar no Widgetbook (OBRIGATÓRIO)
- Criar ou atualizar o arquivo de story em example/lib/widgetbook/
  → Nome do arquivo: <nome_componente>.stories.dart (snake_case)
  → Exemplo: sneaker_subscription_page.stories.dart
- Atualizar example/lib/widgetbook_directories.dart:
  → Adicionar import do arquivo de story
  → Adicionar WidgetbookComponent com WidgetbookUseCase na pasta apropriada
  → Para componentes: adicionar em "Components"
  → Para páginas/templates: adicionar em "Example Pages"

Regras específicas:
- Cada componente deve ter UMA única página no Widgetbook.
- O nome da página deve ser exatamente o nome do componente.
- Estados não criam navegação.
- Estados são controlados por knobs.
- Não criar WidgetbookUseCase por estado.
- Não duplicar componentes para simular variações.
- Ordenar componentes de A a Z.

PROIBIÇÕES:
- Criar componente/página sem criar a story correspondente no Widgetbook.
- Criar componente/página sem atualizar widgetbook_directories.dart.
- Esquecer de exportar o componente no barrel file.

==================================================
FAIL FAST (BLOQUEANTE)
==================================================

- Qualquer inconsistência entre MCP, código Flutter ou Widgetbook:
  → Interromper a geração imediatamente.
- Não gerar código parcial.
- Não corrigir automaticamente.
- O erro deve indicar:
  - Regra violada
  - Dado ausente, ambíguo ou conflitante no MCP

Exceção para MCP parcial:
- Se get_design_context e/ou get_metadata não retornarem dados estruturados,
  mas get_screenshot retornar descrição da UI → PODE prosseguir usando o DEPARA.
- Nome do componente: derivar do contexto (ex: título principal, node-id) em PascalCase
  quando get_metadata não fornecer.

==================================================
FINAL
==================================================

Sem criatividade.
Sem inferências.
Sem otimizações.

O MCP é a fonte da verdade. Quando MCP retornar parcial, o DEPARA é a ponte autorizada.
